// why VarChar(768) ? because it's the largest indexable unicode string type.
// https://stackoverflow.com/questions/72937232/error-1071-42000-specified-key-was-too-long-max-key-length-is-3072-bytes

// some common patterns:
// todo: languages / strings

// tags have both significance and classification
// they look similar, and in a way they are. but more like,
// significance is for specific app-understood behavior. typically for statistics gathering.
// classification is a grouping of items, like song tags "reggae" or "ska" would be grouped as genres.
// classification will be freeform text, maybe or maybe not understood by the app. i guess for future use; not really necessary.

// do not try to change site behavior based on signifacance or classification; then use a dedicated field like eventType rather than tagging as rehearsal / concert.

// journals...
// i think stuff like events should have a timeline with things like "arnold approved this on 4/8" or whatever. that can be derived i guess. but it means attaching dates to things.

// regarding "published" style visibility.
// it's not exactly a user role to assign, because we need to support things like "private" to the author.
// also because users are assigned a SINGLE role.
// really it's more of a style of PERMISSION. so we should
// - mark permissions as usable as visibility or not
// - for visibility of objects, just use a FK to permissions.
// we need to track which user CREATED objects as well, to understand the null visibility.

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
}

// --------------------------------------
model Role {
  id                Int              @id @default(autoincrement())
  name              String           @unique @db.VarChar(768)
  isRoleForNewUsers Boolean          @default(false)
  isPublicRole      Boolean          @default(false)
  description       String?          @db.MediumText
  sortOrder         Int              @default(0)
  color             String?          @db.VarChar(768)
  significance      String? // 
  permissions       RolePermission[]
  User              User[]

  @@index([significance])
  @@index([name])
}

model Permission {
  id           Int     @id @default(autoincrement())
  name         String  @unique @db.VarChar(768)
  isVisibility Boolean @default(false)
  description  String? @db.MediumText
  sortOrder    Int     @default(0)
  significance String? // 
  color        String? @db.VarChar(768)
  iconName     String? @db.VarChar(768)

  roles                              RolePermission[]
  visibilityForSongs                 Song[]
  visibilityForSongComments          SongComment[]
  visibilityForEvents                Event[]
  visibilityForEventComments         EventComment[]
  visibilityForFiles                 File[]
  visibilityForFrontpageGalleryItems FrontpageGalleryItem[]
  visibilityForWikiPages             WikiPage[]
  visibilityForMenuLinks             MenuLink[]

  @@index([name])
  @@index([significance])
  @@index([sortOrder])
}

model RolePermission {
  id           Int        @id @default(autoincrement())
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade) // cascade delete association
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade) // cascade delete association

  // you could also cluster the keys but this is just simpler
  //   @@id([roleId, permissionId])
  @@unique([roleId, permissionId]) // 
}

// effectively this creates "groups" that you can belong to. or indeed just tags... makes sense anyway.
// initial reason for this is attendance groups.
// copied from FileTag
model UserTag {
  id                        Int                 @id @default(autoincrement())
  text                      String              @db.VarChar(768)
  description               String              @db.MediumText
  color                     String?
  significance              String? // 
  sortOrder                 Int                 @default(0)
  cssClass                  String?
  userAssignments           UserTagAssignment[]
  eventsExpectingAttendance Event[]

  @@index([text])
  @@index([sortOrder])
}

// copied from FileTagAssignment
model UserTagAssignment {
  id        Int     @id @default(autoincrement())
  userId    Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userTagId Int
  userTag   UserTag @relation(fields: [userTagId], references: [id], onDelete: Cascade)

  @@unique([userId, userTagId])
}

model User {
  id             Int      @id @default(autoincrement())
  name           String   @default("") @db.VarChar(768)
  isSysAdmin     Boolean  @default(false)
  isDeleted      Boolean  @default(false)
  email          String   @unique @db.VarChar(768)
  phone          String?  @db.VarChar(768)
  hashedPassword String?
  googleId       String?
  createdAt      DateTime @default(now())
  accessToken    String?  @db.VarChar(768) // used like a github access token; a const string which is private and can be used to access resources on your behalf without a session.
  uid            String?  @default(uuid()) // used for unique identification but is NOT secret like the accessToken.

  roleId Int? // nullable for new users a role should be assigned by an admin. null = public
  role   Role? @relation(fields: [roleId], references: [id], onDelete: SetNull) // role deleted, user.roleId set to null.

  tags     UserTagAssignment[]
  tokens   Token[]
  sessions Session[]
  changes  Change[] // yea don't include this in queries

  cssClass String?

  taggedFiles              FileUserTag[]
  uploadedFiles            File[]
  eventSegmentResponses    EventSegmentUserResponse[]
  eventResponses           EventUserResponse[]
  activity                 Activity[]
  songCredits              SongCredit[]
  eventComments            EventComment[]
  songComments             SongComment[]
  instruments              UserInstrument[]
  createdCustomLinks       CustomLink[]
  createdMenuLinks         MenuLink[]
  createdWikiPageRevisions WikiPageRevision[]

  creatorForSongs                Song[]
  creatorForEvents               Event[]
  creatorForEventSongLists       EventSongList[]
  creatorForFrontpageGalleryItem FrontpageGalleryItem[]

  workflowNodeDefaultAssignees      WorkflowDefNodeDefaultAssignee[]
  workflowNodeInstanceAssignees     WorkflowInstanceNodeAssignee[]
  workflowNodeInstanceLastAssignees WorkflowInstanceNodeLastAssignee[]
  workflowLogItems                  WorkflowInstanceLogItem[]

  @@unique([accessToken])
  @@unique([uid])
  @@index([name])
  @@index([isDeleted])
  @@index([email])
  @@index([phone])
  @@index([googleId])
}

model Setting {
  id    Int    @id @default(autoincrement())
  name  String @unique @default("") @db.VarChar(768)
  value String @db.MediumText // json value et al

  @@index([name])
}

model Change {
  id Int @id @default(autoincrement())

  action String // create, update, delete

  context     String @db.VarChar(768) // depends on action / context / whatever
  operationId String // a GUID that groups together all changes that were performed in 1 logical update (for example updating permission relations is many ops, or multiple changing fields)

  table    String
  recordId Int

  changedAt     DateTime @default(now())
  userId        Int?
  sessionHandle String?
  oldValues     String?  @db.MediumText // for create, empty. for update, JSON of fields. for delete, all column values.
  newValues     String?  @db.MediumText // for create & update, JSON of fields. for delete, empty.

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade) // this is one reason not to allow hard deletion of users. any activity of that user should be retained.

  @@index([table])
  @@index([recordId])
  @@index([userId])
}

// activity & changes are different.
// changes is really for minute database changes, for diagnostics / backup / emergency undo
// activity is for analytics.
model Activity {
  id Int @id @default(autoincrement())

  userId        Int?
  sessionHandle String?

  action String //
  data   String? @db.MediumText // additional data for the action

  happenedAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade) // this is one reason not to allow hard deletion of users. any activity of that user should be retained.
}

model Session {
  id                 Int       @id @default(autoincrement())
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?   @db.MediumText
  privateData        String?   @db.MediumText

  user   User? @relation(fields: [userId], references: [id])
  userId Int?
}

model Token {
  id          Int      @id @default(autoincrement())
  hashedToken String
  type        String
  // See note below about TokenType enum
  // type        TokenType
  expiresAt   DateTime
  sentTo      String   @db.VarChar(768)

  user   User @relation(fields: [userId], references: [id])
  userId Int

  @@unique([hashedToken, type])
}

// NOTE: It's highly recommended to use an enum for the token type
//       but enums only work in Postgres.
//       See: https://blitzjs.com/docs/database-overview#switch-to-postgre-sql
// enum TokenType {
//   RESET_PASSWORD
// }

model Song {
  id             Int    @id @default(autoincrement())
  name           String @db.VarChar(768)
  aliases        String @default("") @db.VarChar(768)
  slug           String @db.VarChar(768)
  description    String @db.MediumText
  startBPM       Int?
  endBPM         Int?
  introducedYear Int? // purposely fuzzy

  isDeleted Boolean @default(false)

  lengthSeconds Int? // length. this is approximate, and could vary wildly esp. considering variations.
  // so what about variations like roger variete, or tango long/short versions? do we relate them? or score stuff? i think don't bother; maybe there can be related songs or something but not yet.

  createdByUserId     Int? // required in order to know visibility when visiblePermissionId is NULL
  createdByUser       User?       @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  visiblePermissionId Int? // which permission determines visibility, when NULL, only visible by admins + creator
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  taggedFiles FileSongTag[]
  tags        SongTagAssociation[]
  comments    SongComment[]
  credits     SongCredit[]
  songLists   EventSongListSong[]

  @@index([name])
  @@index([aliases])
  @@index([slug])
  @@index([isDeleted])
  @@index([visiblePermissionId])
}

model SongComment {
  id     Int  @id @default(autoincrement())
  songId Int
  song   Song @relation(fields: [songId], references: [id], onDelete: Cascade) // song deleted = comments too. songs are soft-delete.

  userId    Int
  createdAt DateTime
  updatedAt DateTime
  text      String   @db.MediumText
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade) // users are soft delete; if an admin wants to force delete, then they can go through this.

  visiblePermissionId Int? // which permission determines visibility, when NULL, only visible by admins + creator
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  @@index([songId])
  @@index([visiblePermissionId])
}

// composer / arranger / whatever
model SongCreditType {
  id          Int     @id @default(autoincrement())
  text        String
  description String  @db.MediumText
  color       String?
  sortOrder   Int     @default(0)

  songCredits SongCredit[]

  @@index([text])
  @@index([sortOrder])
}

model SongCredit {
  id     Int   @id @default(autoincrement())
  // some authors may not be users; can specify in comments
  userId Int?
  user   User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  songId Int
  song   Song @relation(fields: [songId], references: [id], onDelete: Cascade)

  year    String @default("") @db.VarChar(768)
  comment String @db.MediumText // markdown

  typeId Int
  type   SongCreditType @relation(fields: [typeId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([songId])
  @@index([typeId])
}

model SongTag {
  id              Int                  @id @default(autoincrement())
  text            String               @db.VarChar(768)
  description     String               @db.MediumText
  color           String?
  significance    String? // we care about some tags, for example gathering specific statistics (you played N concerts - we need to know which events are concerts specifically which is done via tagging)
  showOnSongLists Boolean              @default(false)
  sortOrder       Int                  @default(0)
  songs           SongTagAssociation[]

  @@index([text])
  @@index([significance])
  @@index([showOnSongLists])
  @@index([sortOrder])
}

model SongTagAssociation {
  id     Int     @id @default(autoincrement())
  songId Int
  song   Song    @relation(fields: [songId], references: [id], onDelete: Cascade)
  tagId  Int
  tag    SongTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([tagId, songId])
}

// we could benefit from instrument grouping if they serve some identical purpose.
// for example sousaphone, bass guitar, double bass, serve the same function at events.
// flute, clarinet, sax would all be separate functional groups. so it may be nearly 1:1 with instruments.
// users will associate with instruments like "electric bass" but then when we look at event attendance we see the bass function fulfilled.
// this directly addresses the issue on the google sheet where i can't tell if we have enough drummers
// that's one use in particular that justifies grouping. are there other such uses?

// functional groups are admin-managed.
// individual instruments are user-managed.
model InstrumentFunctionalGroup {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  description String       @db.MediumText
  sortOrder   Int
  color       String?
  instruments Instrument[]

  @@index([name])
  @@index([sortOrder])
}

model Instrument {
  id          Int    @id @default(autoincrement())
  name        String @unique @db.VarChar(768)
  slug        String @default("") @db.VarChar(768)
  description String @db.MediumText
  sortOrder   Int

  // when uploading files to songs, this regex will test if a filename matches this instrument. the directory & extension have been stripped already.
  autoAssignFileLeafRegex String? @db.VarChar(768)

  functionalGroupId Int
  functionalGroup   InstrumentFunctionalGroup  @relation(fields: [functionalGroupId], references: [id], onDelete: Cascade) // if you want to delete a functional group, you need to manually reassign
  instrumentTags    InstrumentTagAssociation[]

  fileTags           FileInstrumentTag[]
  users              UserInstrument[]
  eventUserResponses EventUserResponse[]

  @@index([name])
  @@index([slug])
  @@index([sortOrder])
  @@index([functionalGroupId])
}

model InstrumentTag {
  id           Int                        @id @default(autoincrement())
  text         String                     @db.VarChar(768)
  description  String                     @db.MediumText
  sortOrder    Int                        @default(0)
  color        String?
  significance String? // "uses electricity" for example?
  instruments  InstrumentTagAssociation[]

  @@index([text])
  @@index([sortOrder])
  @@index([significance])
}

// association table
model InstrumentTagAssociation {
  id           Int           @id @default(autoincrement())
  instrumentId Int
  instrument   Instrument    @relation(fields: [instrumentId], references: [id], onDelete: Cascade) // cascade delete association
  tagId        Int
  tag          InstrumentTag @relation(fields: [tagId], references: [id], onDelete: Cascade) // cascade delete association

  @@unique([instrumentId, tagId]) // 
}

model UserInstrument {
  id           Int        @id @default(autoincrement())
  instrumentId Int
  instrument   Instrument @relation(fields: [instrumentId], references: [id], onDelete: Cascade) // cascade delete association
  isPrimary    Boolean    @default(false)
  userId       Int
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade) // cascade delete association

  @@index([userId])
}

// concerts vs. rehearsals? i originally thought these would be tags, but should it just be a dropdown?
// disadvantages of tag:
// - events may not get a type assignment; that's probably not a good idea.
// - events can get multiple conflicting types
// - type is used for things; tag significance is sorta a lame way to accomplish this.
// advantages of dropdown:
// - field is required, structured, queryable, and obvious

// to go further i could make events & rehearsals separate tables. but i don't think that's a good idea; the idea would be that
// they get separate data for the different types. but that's not really the case because this Events table is quite general for events;
// nothing here is specific to any type of event. should that be the case it can be attached somehow.
model Event {
  id                Int        @id @default(autoincrement())
  revision          Int
  calendarInputHash String?    @db.VarChar(200) // ical input payload, to know if revision should be updated.
  name              String     @db.VarChar(768)
  slug              String     @db.VarChar(768)
  description       String     @db.MediumText // what's the diff between a description & comment? description is the pinned general description in markdown.
  typeId            Int?
  type              EventType? @relation(fields: [typeId], references: [id], onDelete: SetNull) // when deleting foreign object,set local id to null

  locationDescription String       @default("") @db.VarChar(768)
  locationURL         String       @default("") @db.VarChar(768)
  isDeleted           Boolean      @default(false)
  // "status" seems kinda more like business logic than a db field. it depends on approvals and spits out either unconfirmed or confirmed.
  // so ideally status is calculated based off approvals & other things. but that locks us into designing for ideal scenarios where everyone is diligent.
  // more practical to just have an enum status.
  statusId            Int?
  status              EventStatus? @relation(fields: [statusId], references: [id], onDelete: SetNull) // when deleting foreign object,set local id to null

  // sets vs. options vs . ???
  segmentBehavior String?

  // don't do this because it's redundant with status. bring it back only if there's a true need.
  // isCancelled Boolean   @default(false) // used as an input for calculating status

  createdAt DateTime
  updatedAt DateTime @default(now()) @updatedAt
  uid       String   @default(uuid())

  // conforms to DateTimeRangeSpec, to encompass all segments. the idea is to be able to sort by event date.
  // normally these are stored in EventSegment, but sorting based on relation like that is not possible (and if it was, it would be VERY messy to manage)
  // so these are to be populated automatically when you change segment dates.
  // for safety, basically any time you change segment data at all:
  // - new segment
  // - change segment
  // - delete segment
  // then we just populate this
  startsAt       DateTime? // date null means TBD
  durationMillis BigInt    @default(0)
  isAllDay       Boolean   @default(true)
  endDateTime    DateTime? // after calculating the date range, this is the "end time" or TBD

  createdByUserId     Int? // required in order to know visibility when visiblePermissionId is NULL
  createdByUser       User?       @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  visiblePermissionId Int? // which permission determines visibility, when NULL, only visible by admins + creator
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  expectedAttendanceUserTagId Int?
  expectedAttendanceUserTag   UserTag? @relation(fields: [expectedAttendanceUserTagId], references: [id], onDelete: SetNull)

  frontpageVisible     Boolean @default(false)
  frontpageDate        String  @default("") @db.VarChar(300) // e.g. "Zaterdag 11 november"
  frontpageTime        String  @default("") @db.VarChar(300) // e.g. 14u
  frontpageDetails     String  @default("") @db.VarChar(300)
  frontpageTitle       String? @db.VarChar(300) // null = use normal one
  frontpageLocation    String? @db.VarChar(300) // null = use normal
  frontpageLocationURI String? @db.VarChar(300) // null = use normal
  frontpageTags        String? @db.VarChar(300) // null, use normal

  frontpageDate_fr        String? @db.VarChar(300) // e.g. "Zaterdag 11 november"
  frontpageTime_fr        String? @db.VarChar(300) // e.g. 14u
  frontpageDetails_fr     String? @db.VarChar(300)
  frontpageTitle_fr       String? @db.VarChar(300) // null = use normal one
  frontpageLocation_fr    String? @db.VarChar(300) // null = use normal
  frontpageLocationURI_fr String? @db.VarChar(300) // null = use normal
  frontpageTags_fr        String? @db.VarChar(300) // null, use normal

  frontpageDate_nl        String? @db.VarChar(300) // e.g. "Zaterdag 11 november"
  frontpageTime_nl        String? @db.VarChar(300) // e.g. 14u
  frontpageDetails_nl     String? @db.VarChar(300)
  frontpageTitle_nl       String? @db.VarChar(300) // null = use normal one
  frontpageLocation_nl    String? @db.VarChar(300) // null = use normal
  frontpageLocationURI_nl String? @db.VarChar(300) // null = use normal
  frontpageTags_nl        String? @db.VarChar(300) // null, use normal

  workflowInstanceId Int?
  workflowInstance   WorkflowInstance? @relation(fields: [workflowInstanceId], references: [id], onDelete: SetNull)

  workflowDefId Int?
  workflowDef   WorkflowDef? @relation(fields: [workflowDefId], references: [id], onDelete: Cascade)

  fileTags  FileEventTag[]
  tags      EventTagAssignment[]
  comments  EventComment[]
  segments  EventSegment[]
  songLists EventSongList[]
  responses EventUserResponse[]

  customFieldValues EventCustomFieldValue[]

  @@unique([uid])
  @@index([name])
  @@index([slug])
  @@index([typeId])
  @@index([isDeleted])
  @@index([statusId])
  @@index([startsAt])
  @@index([endDateTime])
  @@index([visiblePermissionId])
  @@index([frontpageVisible])
  @@index([workflowInstanceId])
  @@index([workflowDefId])
}

model EventCustomField {
  id          Int     @id @default(autoincrement())
  name        String  @db.VarChar(768)
  description String  @db.MediumText // markdown
  dataType    String  @db.MediumText // enum EventCustomFieldDataType
  optionsJson String? @db.MediumText // the options for the option data type of type db3.EventCustomFieldOption[] e.g., "[{ label: 'option 1', color: 'red'}, { label: 'option 2', color: 'blue'}, ]"

  color        String?
  sortOrder    Int     @default(0)
  significance String?
  iconName     String?

  // show this on the user event page (for non-mgrs). for some more technical or verbose values maybe you don't want to show them.
  isVisibleOnEventPage Boolean @default(true)

  eventCustomFieldValues EventCustomFieldValue[]
  //@@index([isVisible])

  @@index([name])
  @@index([sortOrder])
  @@index([significance])
}

model EventCustomFieldValue {
  id            Int              @id @default(autoincrement())
  eventId       Int
  event         Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  customFieldId Int
  customField   EventCustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)

  jsonValue String @db.MediumText

  // in case the field def changes, old values can still reference this.
  dataType String @db.MediumText // enum EventCustomFieldDataType

  @@index([eventId])
  @@index([customFieldId])
}

// events have multiple segments, for example the CM weekend can be broken into saturday, sunday, monday
// concerts may have one or more multiple sets
model EventSegment {
  id      Int   @id @default(autoincrement())
  eventId Int
  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade) // events are soft-delete.

  name        String  @db.VarChar(768)
  description String  @db.MediumText // short description, like 
  uid         String? @default(uuid()) // used for unique identification but is NOT secret like the accessToken.

  // conform to DateTimeRangeSpec
  startsAt       DateTime? // date null means TBD
  durationMillis BigInt
  isAllDay       Boolean   @default(true)

  responses EventSegmentUserResponse[]

  @@index([name])
  @@index([startsAt])
  @@index([eventId])
}

model EventType {
  id           Int     @id @default(autoincrement())
  text         String  @db.VarChar(768)
  description  String  @db.MediumText
  color        String?
  sortOrder    Int     @default(0)
  significance String?
  iconName     String?
  isDeleted    Boolean @default(false)
  events       Event[]

  @@index([text])
  @@index([sortOrder])
  @@index([significance])
  @@index([isDeleted])
}

model EventStatus {
  id           Int     @id @default(autoincrement())
  label        String  @db.VarChar(768)
  description  String  @db.MediumText
  color        String?
  sortOrder    Int     @default(0)
  significance String?
  iconName     String?
  isDeleted    Boolean @default(false)

  events Event[]

  @@index([label])
  @@index([sortOrder])
  @@index([significance])
  @@index([isDeleted])
}

model EventTag {
  id                 Int                  @id @default(autoincrement())
  text               String               @db.VarChar(768)
  description        String               @db.MediumText
  color              String?
  significance       String? // we care about some tags, for example gathering specific statistics (you played N concerts - we need to know which events are concerts specifically which is done via tagging)
  sortOrder          Int                  @default(0)
  visibleOnFrontpage Boolean              @default(false)
  events             EventTagAssignment[]

  @@index([text])
  @@index([significance])
  @@index([sortOrder])
  @@index([visibleOnFrontpage])
}

model EventTagAssignment {
  id         Int      @id @default(autoincrement())
  eventId    Int
  event      Event    @relation(fields: [eventId], references: [id], onDelete: Cascade) // events are soft-delete.
  eventTagId Int
  eventTag   EventTag @relation(fields: [eventTagId], references: [id], onDelete: Cascade) // delete tag = delete the associations.

  @@unique([eventId, eventTagId]) // 
}

model EventComment {
  id        Int      @id @default(autoincrement())
  eventId   Int
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade) // cascade delete association
  userId    Int
  createdAt DateTime
  updatedAt DateTime
  text      String   @db.MediumText
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  visiblePermissionId Int? // which permission determines visibility, when NULL, only visible by admins + creator
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  @@index([eventId])
  @@index([visiblePermissionId])
}

model EventSongList {
  id          Int    @id @default(autoincrement())
  sortOrder   Int    @default(0)
  name        String @db.VarChar(768)
  description String @db.MediumText

  eventId Int
  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade) // when event is deleted, song lists go too.

  songs    EventSongListSong[]
  dividers EventSongListDivider[]

  isOrdered        Boolean @default(true)
  isActuallyPlayed Boolean @default(true)

  // this is really not necessary but it's here so ...
  User   User? @relation(fields: [userId], references: [id])
  userId Int?

  @@index([sortOrder])
  @@index([name])
  @@index([eventId])
}

model EventSongListSong {
  id        Int     @id @default(autoincrement())
  subtitle  String? @db.MediumText // could be a small comment like "short version"
  sortOrder Int     @default(0)

  songId Int
  song   Song @relation(fields: [songId], references: [id], onDelete: Cascade) // when you delete a song, it will disappear from all lists

  eventSongListId Int
  eventSongList   EventSongList @relation(fields: [eventSongListId], references: [id], onDelete: Cascade) // when you delete a song list, delete songs in it.

  @@index([songId])
  @@index([sortOrder])
  @@index([eventSongListId])
}

model EventSongListDivider {
  id        Int     @id @default(autoincrement())
  subtitle  String? @db.MediumText // could be a small comment like "15 min break"
  sortOrder Int     @default(0)

  eventSongListId Int
  eventSongList   EventSongList @relation(fields: [eventSongListId], references: [id], onDelete: Cascade) // when you delete a song list, delete songs in it.

  @@index([sortOrder])
  @@index([eventSongListId])
}

// things like yes, no, not-sure-yes, not-sure-no, partially
model EventAttendance {
  id        Int @id @default(autoincrement())
  sortOrder Int @default(0)

  text             String  @db.VarChar(768) // generic button text ("yes", "probably")
  personalText     String  @default("") // more personal text explanation ("you are going", "you are probably going")
  pastText         String  @default("") // "went"
  pastPersonalText String  @default("") // "you went"
  isActive         Boolean @default(true) // is it offered to users as an option?

  description String  @db.MediumText // explanation
  color       String?
  iconName    String?
  strength    Int // in order to be able to filter people who aren't coming. let's consider like, 50 = threshold for YES/NO. effectively a sort order.
  isDeleted   Boolean @default(false)

  responses EventSegmentUserResponse[]

  @@index([sortOrder])
  @@index([strength])
  @@index([isDeleted])
}

model EventUserResponse {
  id      Int @id @default(autoincrement())
  userId  Int
  eventId Int

  revision Int     @default(1)
  uid      String? @default(uuid())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // NB: #162 your user tag overrides this. this flag is only used to invite people who don't have the tag.
  isInvited    Boolean?
  userComment  String?     @db.MediumText
  instrumentId Int? // specify the specific instrument
  instrument   Instrument? @relation(fields: [instrumentId], references: [id], onDelete: SetNull) // delete instrument, set to null

  @@unique([userId, eventId]) // 
}

model EventSegmentUserResponse {
  id             Int @id @default(autoincrement())
  userId         Int
  eventSegmentId Int

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventSegment EventSegment @relation(fields: [eventSegmentId], references: [id], onDelete: Cascade)

  attendanceId Int?
  attendance   EventAttendance? @relation(fields: [attendanceId], references: [id], onDelete: SetNull)

  @@unique([userId, eventSegmentId]) // 
}

// tech rider, partition, invoice, contract, event media, other, what is the usage?
model FileTag {
  id              Int                 @id @default(autoincrement())
  text            String              @db.VarChar(768)
  description     String              @db.MediumText
  color           String?
  significance    String? // 
  sortOrder       Int                 @default(0)
  fileAssignments FileTagAssignment[]

  @@index([text])
  @@index([significance])
  @@index([sortOrder])
}

model FileTagAssignment {
  id        Int     @id @default(autoincrement())
  fileId    Int
  file      File    @relation(fields: [fileId], references: [id], onDelete: Cascade) // files are soft-delete.
  fileTagId Int
  fileTag   FileTag @relation(fields: [fileTagId], references: [id], onDelete: Cascade) // delete tag = delete the associations.

  @@unique([fileId, fileTagId]) // 
}

// files can also just be floating uploads for example dropped into a markdown field
// TODO: default sorting should probably be implemented. and depending on where it's being viewed it may be different.
// so let's not work on this now; see how it feels necessary.
model File {
  id             Int     @id @default(autoincrement())
  fileLeafName   String  @db.VarChar(768) // the name of the file as it was uploaded, visible to (& editable) users. IMG20113.jpg for example.
  storedLeafName String  @unique @db.VarChar(768) // a unique filename used in server storage; a guid probably. this is also what is used in params for identifying files.
  description    String  @db.MediumText
  isDeleted      Boolean @default(false)
  sizeBytes      Int? // null for external URIs

  externalURI String? @db.VarChar(768) // dropbox link for example

  // the date of the file. for example WHEN was the photo taken? WHEN was the recording taken? WHEN was the document created?
  // some files just don't have dates so probably use uploadDate as a fallback.
  fileCreatedAt DateTime?

  uploadedAt          DateTime
  uploadedByUserId    Int?
  uploadedByUser      User?       @relation(fields: [uploadedByUserId], references: [id], onDelete: SetNull)
  visiblePermissionId Int?
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  mimeType   String?
  customData String? @db.MediumText // JSON of FileCustomData that will depend how i feel like using it based on mimetype. links to thumbnails, metadata, pdf series of thumbnails, whatev.

  // a file (which should be a child) which serves as a preview. for example if the audio file is some huge .wav, this can be a lower-quality download-friendly MP3 version
  // or for huge photos, this is a low-bandwidth small preview.
  previewFileId Int?
  previewFile   File? @relation("previewFiles", fields: [previewFileId], references: [id], onDelete: SetNull)

  // if this file was generated from another file, this forms that relationship.
  parentFileId Int?
  parentFile   File? @relation("fileHierarchy", fields: [parentFileId], references: [id], onDelete: SetNull)

  tags                  FileTagAssignment[]
  taggedUsers           FileUserTag[]
  taggedSongs           FileSongTag[]
  taggedEvents          FileEventTag[]
  taggedInstruments     FileInstrumentTag[]
  frontpageGalleryItems FrontpageGalleryItem[]

  previewForFile File[] @relation("previewFiles")
  childFiles     File[] @relation("fileHierarchy")

  @@index([fileLeafName])
  @@index([storedLeafName])
  @@index([isDeleted])
  @@index([visiblePermissionId])
  @@index([mimeType])
  @@index([previewFileId])
  @@index([parentFileId])
}

model FileUserTag {
  id     Int  @id @default(autoincrement())
  fileId Int
  file   File @relation(fields: [fileId], references: [id], onDelete: Cascade)
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int

  @@unique([fileId, userId]) // 
  @@index([fileId])
  @@index([userId])
}

model FileSongTag {
  id     Int  @id @default(autoincrement())
  fileId Int
  file   File @relation(fields: [fileId], references: [id], onDelete: Cascade)
  song   Song @relation(fields: [songId], references: [id], onDelete: Cascade)
  songId Int

  @@unique([fileId, songId]) // 
  @@index([fileId])
  @@index([songId])
}

model FileEventTag {
  id      Int   @id @default(autoincrement())
  fileId  Int
  file    File  @relation(fields: [fileId], references: [id], onDelete: Cascade)
  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId Int

  @@unique([fileId, eventId]) // 
  @@index([fileId])
  @@index([eventId])
}

// this is hm. i suppose this is correct, but tagging instrument groups may be more accurate in some scenarios?
model FileInstrumentTag {
  id           Int        @id @default(autoincrement())
  fileId       Int
  file         File       @relation(fields: [fileId], references: [id], onDelete: Cascade)
  instrument   Instrument @relation(fields: [instrumentId], references: [id], onDelete: Cascade)
  instrumentId Int

  @@unique([fileId, instrumentId]) // 
  @@index([fileId])
  @@index([instrumentId])
}

model FrontpageGalleryItem {
  id            Int     @id @default(autoincrement())
  isDeleted     Boolean @default(false) //  soft delete. when hidden, users won't see them.
  caption       String  @db.MediumText // markdown
  caption_nl    String? @db.MediumText // markdown
  caption_fr    String? @db.MediumText // markdown
  sortOrder     Int     @default(0)
  fileId        Int
  file          File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  displayParams String  @db.MediumText // JSON of GalleryImageDisplayParams

  createdByUserId     Int? // required in order to know visibility when visiblePermissionId is NULL
  createdByUser       User?       @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  visiblePermissionId Int?
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  @@index([isDeleted])
  @@index([sortOrder])
  @@index([fileId])
  @@index([visiblePermissionId])
}

model CustomLink {
  id                  Int     @id @default(autoincrement())
  name                String  @db.VarChar(768)
  description         String  @db.MediumText
  slug                String  @db.VarChar(768)
  destinationURL      String  @db.VarChar(768)
  redirectType        String // potentially various options like temporary / permanent redirect etc.
  forwardQuery        Boolean @default(false) // forward the query string?
  intermediateMessage String? @db.MediumText // for intermediate page type, this is the message users will see.

  createdByUserId Int?
  createdByUser   User?    @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdAt       DateTime @default(now())

  visits CustomLinkVisit[]

  @@unique([slug])
  @@index([name])
}

model CustomLinkVisit {
  id           Int      @id @default(autoincrement())
  customLinkId Int
  visitedAt    DateTime @default(now())
  visitorIP    String?  @db.VarChar(256)
  userAgent    String?  @db.MediumText
  referrerURL  String?  @db.MediumText
  URI          String?  @db.MediumText

  customLink CustomLink @relation(fields: [customLinkId], references: [id], onDelete: Cascade)
}

model WikiPage {
  id   Int    @id @default(autoincrement())
  slug String @db.VarChar(768) // slugified name. name can be changed in Revision

  visiblePermissionId Int?
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  revisions WikiPageRevision[]

  @@unique([slug])
  @@index([visiblePermissionId])
}

model WikiPageRevision {
  id Int @id @default(autoincrement())

  wikiPageId Int
  wikiPage   WikiPage @relation(fields: [wikiPageId], references: [id], onDelete: Cascade)

  name    String @db.VarChar(768)
  content String @db.MediumText

  createdByUserId Int?
  createdByUser   User?    @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdAt       DateTime @default(now())

  @@index([name])
  @@index([wikiPageId])
}

model MenuLink {
  id        Int @id @default(autoincrement())
  sortOrder Int @default(0)

  realm String? @db.VarChar(768)

  groupName     String @db.VarChar(768)
  groupCssClass String @db.VarChar(768)

  itemCssClass String @db.VarChar(768)
  linkType     String @db.VarChar(768) // external, application, wiki

  // for external, this is a URL
  // for application, this is empty.
  // for wiki, this is the slug
  externalURI     String? @db.MediumText
  applicationPage String? @db.VarChar(768) // an enum.
  wikiSlug        String? @db.VarChar(768)

  iconName String? @db.VarChar(768)
  caption  String  @db.VarChar(768)

  visiblePermissionId Int?
  visiblePermission   Permission? @relation(fields: [visiblePermissionId], references: [id], onDelete: SetNull)

  createdByUserId Int?
  createdByUser   User?    @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdAt       DateTime @default(now())

  @@index([caption])
  @@index([realm])
  @@index([visiblePermissionId])
}

model WorkflowDef {
  id                 Int     @id @default(autoincrement())
  sortOrder          Int     @default(0)
  name               String  @db.VarChar(768)
  description        String  @db.MediumText
  color              String? @db.VarChar(768)
  isDefaultForEvents Boolean

  groups    WorkflowDefGroup[]
  nodeDefs  WorkflowDefNode[]
  instances WorkflowInstance[]
  events    Event[]

  @@index([name])
}

model WorkflowDefGroup {
  id            Int     @id @default(autoincrement())
  workflowDefId Int
  name          String  @db.VarChar(768)
  description   String  @db.MediumText
  color         String? @db.VarChar(768)

  positionX Float?
  positionY Float?
  width     Float?
  height    Float?
  selected  Boolean

  workflowDef WorkflowDef       @relation(fields: [workflowDefId], references: [id], onDelete: Cascade)
  nodes       WorkflowDefNode[]

  @@index([name])
  @@index([selected])
}

model WorkflowDefNode {
  id          Int    @id @default(autoincrement())
  name        String @db.VarChar(768)
  description String @db.MediumText

  groupId Int?
  group   WorkflowDefGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)

  workflowDefId Int?
  workflowDef   WorkflowDef? @relation(fields: [workflowDefId], references: [id], onDelete: Cascade)

  displayStyle           String @db.VarChar(768)
  manualCompletionStyle  String @db.VarChar(768) // WorkflowManualCompletionStyle
  thisNodeProgressWeight Int

  relevanceCriteriaType  String @db.VarChar(768) // WorkflowCompletionCriteriaType;
  activationCriteriaType String @db.VarChar(768) // WorkflowCompletionCriteriaType;
  completionCriteriaType String @db.VarChar(768) // WorkflowCompletionCriteriaType;

  fieldName          String? @db.VarChar(768)
  fieldValueOperator String? @db.VarChar(768)
  fieldValueOperand2 String? @db.MediumText // JSON ? not sure how this will be serialized.

  defaultDueDateDurationDaysAfterStarted Int?
  positionX                              Float?
  positionY                              Float?
  width                                  Float?
  height                                 Float?
  selected                               Boolean

  logItems         WorkflowInstanceLogItem[]
  instances        WorkflowInstanceNode[]
  defaultAssignees WorkflowDefNodeDefaultAssignee[]

  dependenciesAsSource WorkflowDefNodeDependency[] @relation("source")
  dependenciesAsTarget WorkflowDefNodeDependency[] @relation("target")

  @@index([name])
  @@index([workflowDefId])
  @@index([groupId])
  @@index([displayStyle])
}

model WorkflowDefNodeDefaultAssignee {
  id        Int             @id @default(autoincrement())
  nodeDefId Int
  nodeDef   WorkflowDefNode @relation(fields: [nodeDefId], references: [id], onDelete: Cascade)

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([nodeDefId])
  @@index([userId])
}

model WorkflowDefNodeDependency {
  id                     Int     @id @default(autoincrement())
  selected               Boolean
  determinesRelevance    Boolean
  determinesActivation   Boolean
  determinesCompleteness Boolean

  sourceNodeDefId Int
  sourceNodeDef   WorkflowDefNode @relation(fields: [sourceNodeDefId], references: [id], onDelete: Cascade, name: "source")

  targetNodeDefId Int
  targetNodeDef   WorkflowDefNode @relation(fields: [targetNodeDefId], references: [id], onDelete: Cascade, name: "target")

  @@index([selected])
}

model WorkflowInstance {
  id Int @id @default(autoincrement())

  revision Int @default(1)

  lastEvaluatedWorkflowDefId Int?
  lastEvaluatedWorkflowDef   WorkflowDef? @relation(fields: [lastEvaluatedWorkflowDefId], references: [id], onDelete: Cascade)

  logItems WorkflowInstanceLogItem[]
  nodes    WorkflowInstanceNode[]

  events Event[]

  @@index([lastEvaluatedWorkflowDefId])
}

model WorkflowInstanceLogItem {
  id         Int              @id @default(autoincrement())
  instanceId Int
  instance   WorkflowInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  at   DateTime
  type String   @db.VarChar(768)

  nodeDefId Int
  nodeDef   WorkflowDefNode @relation(fields: [nodeDefId], references: [id], onDelete: Cascade)

  userId Int?
  user   User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  fieldName String? @db.VarChar(768)

  oldValue String? @db.MediumText // JSON 
  newValue String? @db.MediumText // JSON
  comment  String? @db.MediumText // JSON

  @@index([instanceId])
  @@index([nodeDefId])
  @@index([userId])
}

model WorkflowInstanceNode {
  id         Int              @id @default(autoincrement())
  instanceId Int
  instance   WorkflowInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  nodeDefId  Int
  nodeDef    WorkflowDefNode  @relation(fields: [nodeDefId], references: [id], onDelete: Cascade) // it's kinda tempting to setNull here, maybe useful but cascade is just simpler.

  dueDate                     DateTime?
  activeStateFirstTriggeredAt DateTime?

  manuallyCompleted       Boolean
  manualCompletionComment String? @db.MediumText

  lastFieldName          String? @db.VarChar(768)
  lastFieldValueAsString String? @db.MediumText
  lastProgressState      String? @db.VarChar(768) // WorkflowNodeProgressState

  assignees     WorkflowInstanceNodeAssignee[]
  lastAssignees WorkflowInstanceNodeLastAssignee[]

  @@index([instanceId])
  @@index([nodeDefId])
}

model WorkflowInstanceNodeLastAssignee {
  id             Int                  @id @default(autoincrement())
  userId         Int
  user           User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  instanceNodeId Int
  instanceNode   WorkflowInstanceNode @relation(fields: [instanceNodeId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([instanceNodeId])
}

model WorkflowInstanceNodeAssignee {
  id             Int                  @id @default(autoincrement())
  userId         Int
  user           User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  instanceNodeId Int
  instanceNode   WorkflowInstanceNode @relation(fields: [instanceNodeId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([instanceNodeId])
}
