// some common patterns:

// sortOrder   Int              @default(0)
// isDeleted      Boolean             @default(false)
// significance String? // for tags
// isPublished Boolean @default(false)

// TODO:
// website integration (fields for events, image editing, whether it's published etc)

// journals...
// i think stuff like events should have a timeline with things like "arnold approved this on 4/8" or whatever. that can be derived i guess. but it means attaching dates to things.

// note about soft delete. for the moment, just song, user, event
// at least for the moment, FK relations with soft-delete objects should onDelete:Restrict.
// rationale: soft delete is for objects with a lot of data attached so we don't lose much. so the onDelete
// action should rarely be invoked. only by some kind of exceptional admin action. and in that case we should respect
// the fact that it's a sort of emergency action and play it safe. if you can hard-delete objects via admin, then you can 
// hard-delete the related objects first.

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// note that we can generate model types which include related objects like this:
// https://github.com/prisma/prisma/discussions/10928
// type FactionWithOwner = Prisma.FactionGetPayload<{
//   include: { owner: true }
// }>

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
}

// --------------------------------------

model Role {
  id          Int              @id @default(autoincrement())
  name        String           @unique
  description String?
  sortOrder   Int              @default(0)
  permissions RolePermission[]
  User        User[]
}

model Permission {
  id          Int              @id @default(autoincrement())
  name        String           @unique
  description String?
  sortOrder   Int              @default(0)
  roles       RolePermission[]
}

model RolePermission {
  id           Int        @id @default(autoincrement())
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade) // cascade delete association
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade) // cascade delete association

  // you could also cluster the keys but this is just simpler
  //   @@id([roleId, permissionId])
  @@unique([roleId, permissionId]) // 
}

model User {
  id             Int       @id @default(autoincrement())
  name           String    @default("")
  isSysAdmin     Boolean   @default(false)
  isDeleted      Boolean   @default(false)
  email          String    @unique
  phone          String?
  hashedPassword String?
  googleId       String?
  createdAt     DateTime @default(now())

  roleId         Int? // nullable for new users a role should be assigned by an admin. null = public
  role           Role?     @relation(fields: [roleId], references: [id], onDelete: SetNull) // role deleted, user.roleId set to null.
  tokens         Token[]
  sessions       Session[]
  changes        Change[] // yea don't include this in queries

  taggedFiles    FileUserTag[]
  eventResponses EventUserResponse[]
  activity       Activity[]
  songCredits    SongCredit[]
  eventComments  EventComment[]
  songComments   SongComment[]
  instruments    UserInstrument[]
}

model Setting {
  id    Int    @id @default(autoincrement())
  name  String @unique @default("")
  value String @default("") // json value
}

model Change {
  id Int @id @default(autoincrement())

  action String // create, update, delete

  context     String // depends on 
  operationId String // a GUID that groups together all changes that were performed in 1 logical update (for example updating permission relations is many ops, or multiple changing fields)

  table    String
  recordId Int

  changedAt     DateTime @default(now())
  userId        Int?
  sessionHandle String?
  oldValues     String? // for create, empty. for update, JSON of fields. for delete, all column values.
  newValues     String? // for create & update, JSON of fields. for delete, empty.

  user User? @relation(fields: [userId], references: [id], onDelete: Restrict) // this is one reason not to allow hard deletion of users. any activity of that user should be retained.
}

// activity & changes are different.
// changes is really for minute database changes, for diagnostics / backup / emergency undo
// activity is for analytics.
model Activity {
  id Int @id @default(autoincrement())

  userId        Int?
  sessionHandle String?

  action String //
  data   String? // additional data for the action

  happenedAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: Restrict) // this is one reason not to allow hard deletion of users. any activity of that user should be retained.
}

model Session {
  id                 Int       @id @default(autoincrement())
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?

  user   User? @relation(fields: [userId], references: [id])
  userId Int?
}

model Token {
  id          Int      @id @default(autoincrement())
  hashedToken String
  type        String
  // See note below about TokenType enum
  // type        TokenType
  expiresAt   DateTime
  sentTo      String

  user   User @relation(fields: [userId], references: [id])
  userId Int

  @@unique([hashedToken, type])
}

// NOTE: It's highly recommended to use an enum for the token type
//       but enums only work in Postgres.
//       See: https://blitzjs.com/docs/database-overview#switch-to-postgre-sql
// enum TokenType {
//   RESET_PASSWORD
// }

model Song {
  id             Int     @id @default(autoincrement())
  name           String
  slug           String
  startKey       String?
  endKey         String?
  startBPM       Int?
  endBPM         Int?
  introducedYear Int? // purposely fuzzy

  isDeleted Boolean @default(false)

  lengthSeconds Int? // length. this is approximate, and could vary wildly esp. considering variations.
  // so what about variations like roger variete, or tango long/short versions? do we relate them? or score stuff? i think don't bother; maybe there can be related songs or something but not yet.

  FileSongTag FileSongTag[]
  tags        SongTagAssociation[]
  comments    SongComment[]
  credits     SongCredit[]
  songLists   EventSongListSong[]
}

model SongComment {
  id        Int  @id @default(autoincrement())
  songId    Int
  song      Song @relation(fields: [songId], references: [id], onDelete: Restrict) // song deleted = comments too. songs are soft-delete.
  sortOrder Int  @default(0)

  userId    Int
  createdAt DateTime
  updatedAt DateTime
  text      String
  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict) // users are soft delete; if an admin wants to force delete, then they can go through this.

  // we want users to be able to unpublish things they edit.
  // deletes are always hard.
  isPublished Boolean @default(false)

  //@@unique([songId, commentId])
}

model SongCredit {
  id         Int     @id @default(autoincrement())
  type       String // composer / arranger / whatever
  userId     Int?
  user       User?   @relation(fields: [userId], references: [id], onDelete: Restrict)
  userString String? // in case there's no user for this, type-in.
  songId     Int
  song       Song    @relation(fields: [songId], references: [id], onDelete: Restrict)
  sortOrder  Int     @default(0)

  @@unique([userId, songId])
}

model SongTag {
  id           Int                  @id @default(autoincrement())
  text         String
  color        String?
  significance String? // we care about some tags, for example gathering specific statistics (you played N concerts - we need to know which events are concerts specifically which is done via tagging)
  songs        SongTagAssociation[]
}

model SongTagAssociation {
  id     Int     @id @default(autoincrement())
  songId Int
  song   Song    @relation(fields: [songId], references: [id], onDelete: Restrict)
  tagId  Int
  tag    SongTag @relation(fields: [tagId], references: [id], onDelete: Restrict)

  @@unique([tagId, songId])
}

// we could benefit from instrument grouping if they serve some identical purpose.
// for example sousaphone, bass guitar, double bass, serve the same function at events.
// flute, clarinet, sax would all be separate functional groups. so it may be nearly 1:1 with instruments.
// users will associate with instruments like "electric bass" but then when we look at event attendance we see the bass function fulfilled.
// this directly addresses the issue on the google sheet where i can't tell if we have enough drummers
// that's one use in particular that justifies grouping. are there other such uses?

// functional groups are admin-managed.
// individual instruments are user-managed.
model InstrumentFunctionalGroup {
  id          Int          @id @default(autoincrement())
  name        String
  description String       @default("")
  sortOrder   Int
  color       String?
  instruments Instrument[]
}

model Instrument {
  id                Int                        @id @default(autoincrement())
  name              String
  description       String                     @default("")
  sortOrder         Int
  functionalGroupId Int
  functionalGroup   InstrumentFunctionalGroup  @relation(fields: [functionalGroupId], references: [id], onDelete: Restrict) // if you want to delete a functional group, you need to manually reassign
  instrumentTags    InstrumentTagAssociation[]

  fileTags FileInstrumentTag[]
  users    UserInstrument[]
}

model InstrumentTag {
  id           Int                        @id @default(autoincrement())
  text         String
  description  String                     @default("")
  sortOrder    Int                        @default(0)
  color        String?
  significance String? // "uses electricity" for example?
  instruments  InstrumentTagAssociation[]
}

// association table
model InstrumentTagAssociation {
  id           Int           @id @default(autoincrement())
  instrumentId Int
  instrument   Instrument    @relation(fields: [instrumentId], references: [id], onDelete: Cascade) // cascade delete association
  tagId        Int
  tag          InstrumentTag @relation(fields: [tagId], references: [id], onDelete: Cascade) // cascade delete association

  @@unique([instrumentId, tagId]) // 
}

model UserInstrument {
  id           Int        @id @default(autoincrement())
  instrumentId Int
  instrument   Instrument @relation(fields: [instrumentId], references: [id], onDelete: Cascade) // cascade delete association
  userId       Int
  user         User       @relation(fields: [userId], references: [id], onDelete: Restrict) // cascade delete association
}

// concerts vs. rehearsals? i originally thought these would be tags, but should it just be a dropdown?
// disadvantages of tag:
// - events may not get a type assignment; that's probably not a good idea.
// - events can get multiple conflicting types
// - type is used for things; tag significance is sorta a lame way to accomplish this.
// advantages of dropdown:
// - field is required, structured, queryable, and obvious

// to go further i could make events & rehearsals separate tables. but i don't think that's a good idea; the idea would be that
// they get separate data for the different types. but that's not really the case because this Events table is quite general for events;
// nothing here is specific to any type of event. should that be the case it can be attached somehow.
model Event {
  id                  Int      @id @default(autoincrement())
  name                String
  slug                String
  description         String // what's the diff between a description & comment? description is the pinned general description in markdown.
  startsAt            DateTime
  endsAt              DateTime
  locationDescription String   @default("")
  locationURL         String   @default("")
  isDeleted           Boolean  @default(false)
  // status - new -> request responses -> confirmed with organizer  -> confirmed
  //                                      confirmed with group
  //                                      confirmed with directors
  // "status" seems kinda more like business logic than a db field. it depends on approvals and spits out either unconfirmed or confirmed.
  isCancelled         Boolean  @default(false) // used as an input for calculating status

  createdAt DateTime

  // contact people ?
  // links ?
  // workflow confirmation etc.
  fileTags  FileEventTag[]
  tags      EventTagAssignment[]
  responses EventUserResponse[]
  comments  EventComment[]
  songLists EventSongList[]
}

model EventTag {
  id           Int                  @id @default(autoincrement())
  text         String
  description  String               @default("")
  color        String?
  significance String? // we care about some tags, for example gathering specific statistics (you played N concerts - we need to know which events are concerts specifically which is done via tagging)
  events       EventTagAssignment[]
}

model EventTagAssignment {
  id         Int      @id @default(autoincrement())
  eventId    Int
  event      Event    @relation(fields: [eventId], references: [id], onDelete: Restrict) // events are soft-delete.
  eventTagId Int
  eventTag   EventTag @relation(fields: [eventTagId], references: [id], onDelete: Cascade) // delete tag = delete the associations.

  @@unique([eventId, eventTagId]) // 
}

model EventComment {
  id        Int      @id @default(autoincrement())
  eventId   Int
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Restrict) // cascade delete association
  userId    Int
  createdAt DateTime
  updatedAt DateTime
  text      String
  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict)

  // we want users to be able to unpublish things they edit.
  // deletes are always hard.
  isPublished Boolean @default(false)
}

model EventSongList {
  id          Int    @id @default(autoincrement())
  eventId     Int
  sortOrder   Int    @default(0)
  name        String
  description String @default("")
  event       Event  @relation(fields: [eventId], references: [id], onDelete: Restrict) // when event is deleted, song lists go too.
}

model EventSongListSong {
  id       Int     @id @default(autoincrement())
  songId   Int
  subtitle String? // could be a small comment like "short version"

  song Song @relation(fields: [songId], references: [id], onDelete: Restrict) // when you delete a song, it will disappear from all lists
}

// tech rider, invoice, contract, event media, other, what is the usage? the point is to find similar things
model FileSignificance {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?
  Files       File[]
}

// files can also just be floating uploads for example dropped into a markdown field
model File {
  id             Int     @id @default(autoincrement())
  fileLeafName   String // the name of the file as it was uploaded, visible to users. IMG20113.jpg for example.
  storedLeafName String // a unique filename used in server storage; a guid probably.
  uri            String // if this is a link, then here's the URI
  description    String
  type           String // enum (video, photo, link, partition)
  significanceId Int?
  isDeleted      Boolean @default(false)

  subtitle String? // could be a small comment like "short version"

  significance      FileSignificance?   @relation(fields: [significanceId], references: [id], onDelete: SetNull) // when you delete a significance, set null.
  taggedUsers       FileUserTag[]
  taggedSongs       FileSongTag[]
  taggedEvents      FileEventTag[]
  taggedInstruments FileInstrumentTag[]
}

model FileUserTag {
  id     Int     @id @default(autoincrement())
  fileId Int
  file   File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name   String? // if userid is not there...
  user   User?   @relation(fields: [userId], references: [id], onDelete: Restrict)
  userId Int?

  @@unique([fileId, userId]) // 
}

model FileSongTag {
  id     Int     @id @default(autoincrement())
  fileId Int
  file   File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name   String? // if songid is not there...
  song   Song?   @relation(fields: [songId], references: [id], onDelete: Restrict)
  songId Int?

  @@unique([fileId, songId]) // 
}

model FileEventTag {
  id      Int     @id @default(autoincrement())
  fileId  Int
  file    File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name    String? // if eventid is not there...
  event   Event?  @relation(fields: [eventId], references: [id], onDelete: Restrict)
  eventId Int?

  @@unique([fileId, eventId]) // 
}

// this is hm. i suppose this is correct, but tagging instrument groups may be more accurate in some scenarios?
model FileInstrumentTag {
  id           Int         @id @default(autoincrement())
  fileId       Int
  file         File        @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name         String? // if instrumentid is not there...
  instrument   Instrument? @relation(fields: [instrumentId], references: [id], onDelete: Cascade)
  instrumentId Int?

  @@unique([fileId, instrumentId]) // 
}

// things like yes no maybe
model EventAttendance {
  id        Int     @id @default(autoincrement())
  text      String
  color     String?
  strength  Int // in order to be able to filter people who aren't coming.
  isDeleted Boolean @default(false)

  responses EventUserResponse[]
}

model EventApproval {
  id        Int     @id @default(autoincrement())
  text      String
  color     String?
  strength  Int // in order to be able to filter people who aren't coming.
  isDeleted Boolean @default(false)

  responses EventUserResponse[]
}

model EventUserResponse {
  id      Int   @id @default(autoincrement())
  userId  Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Restrict)
  eventId Int
  event   Event @relation(fields: [eventId], references: [id], onDelete: Restrict)

  expectApproval   Boolean @default(false)
  expectAttendance Boolean @default(false)

  attendanceId   Int?
  attendance     EventAttendance? @relation(fields: [attendanceId], references: [id], onDelete: SetDefault)
  attendanceText String?

  approvalId   Int?
  approval     EventApproval? @relation(fields: [approvalId], references: [id], onDelete: SetDefault)
  approvalText String?

  @@unique([userId, eventId]) // 
}
