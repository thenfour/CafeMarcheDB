// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// note that we can generate model types which include related objects like this:
// https://github.com/prisma/prisma/discussions/10928
// type FactionWithOwner = Prisma.FactionGetPayload<{
//   include: { owner: true }
// }>

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
}

// --------------------------------------

model Role {
  id          Int              @id @default(autoincrement())
  name        String           @unique
  description String?
  sortOrder   Int              @default(0)
  permissions RolePermission[]
  User        User[]
}

model Permission {
  id          Int              @id @default(autoincrement())
  name        String           @unique
  description String?
  sortOrder   Int              @default(0)
  roles       RolePermission[]
}

model RolePermission {
  id           Int        @id @default(autoincrement())
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // you could also cluster the keys but this is just simpler
  //   @@id([roleId, permissionId])
  @@unique([roleId, permissionId]) // 
}

model User {
  id             Int                 @id @default(autoincrement())
  name           String              @default("")
  isSysAdmin     Boolean             @default(false)
  isDeleted      Boolean             @default(false)
  email          String              @unique
  phone          String?
  hashedPassword String?
  googleId       String?
  roleId         Int? // nullable for new users a role should be assigned by an admin. null = public
  role           Role?               @relation(fields: [roleId], references: [id])
  tokens         Token[]
  sessions       Session[]
  Changes        Changes[] // yea don't include this
  taggedFiles    FileUserTag[]
  eventResponses EventUserResponse[]
}

model Changes {
  id Int @id @default(autoincrement())

  context String
  operationId String // a GUID that groups together all changes that were performed in 1 logical update (for example updating permission relations is many ops, or multiple changing fields)

  table    String
  //column   String
  recordId Int
  action   String // create, update, delete

  changedAt DateTime @default(now())
  userId    Int?
  oldValues String? // for create, empty. for update, JSON of fields. for delete, all column values.
  newValues String? // for create & update, JSON of fields. for delete, empty.

  user User? @relation(fields: [userId], references: [id])
}

model Session {
  id                 Int       @id @default(autoincrement())
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?

  user   User? @relation(fields: [userId], references: [id])
  userId Int?
}

model Token {
  id          Int      @id @default(autoincrement())
  hashedToken String
  type        String
  // See note below about TokenType enum
  // type        TokenType
  expiresAt   DateTime
  sentTo      String

  user   User @relation(fields: [userId], references: [id])
  userId Int

  @@unique([hashedToken, type])
}

// NOTE: It's highly recommended to use an enum for the token type
//       but enums only work in Postgres.
//       See: https://blitzjs.com/docs/database-overview#switch-to-postgre-sql
// enum TokenType {
//   RESET_PASSWORD
// }

model Song {
  id          Int           @id @default(autoincrement())
  name        String
  // ... metadata bpm composer etc.
  // so what about variations like roger variete? do we relate them? or score stuff? i think don't bother; maybe there can be related songs or something but not yet.
  FileSongTag FileSongTag[]
}

// let's support 2 levels of instruments. it's just practical.
// mostly for coloring, so this is a pretty high level thing like "drums", "strings", "high instruments"
// honestly not sure how useful this is.
model InstrumentGroup {
  id          Int          @id @default(autoincrement())
  name        String
  color       String
  scoreOrder  Int
  instruments Instrument[]
}

// 
model Instrument {
  id                Int                 @id @default(autoincrement())
  name              String
  scoreOrder        Int
  instrumentGroup   InstrumentGroup?    @relation(fields: [instrumentGroupId], references: [id], onDelete: SetNull)
  instrumentGroupId Int?
  fileTags          FileInstrumentTag[]
}

model Event {
  id        Int                  @id @default(autoincrement())
  name      String
  occursAt  DateTime
  // contact people ?
  // links ?
  // details ?
  // workflow confirmation etc.
  fileTags  FileEventTag[]
  tags      EventTagAssignment[]
  responses EventUserResponse[]
}

model EventTag {
  id     Int                  @id @default(autoincrement())
  text   String
  color  String
  events EventTagAssignment[]
}

model EventTagAssignment {
  id         Int      @id @default(autoincrement())
  eventId    Int
  event      Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventTagId Int
  eventTag   EventTag @relation(fields: [eventTagId], references: [id], onDelete: Cascade)

  @@unique([eventId, eventTagId]) // 
}

model File {
  id                Int                 @id @default(autoincrement())
  filename          String
  description       String
  type              String //  (video, photo, link, partition)
  taggedUsers       FileUserTag[]
  taggedSongs       FileSongTag[]
  taggedEvents      FileEventTag[]
  taggedInstruments FileInstrumentTag[]
}

model FileUserTag {
  id     Int     @id @default(autoincrement())
  fileId Int
  file   File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name   String? // if userid is not there...
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int?

  @@unique([fileId, userId]) // 
}

model FileSongTag {
  id     Int     @id @default(autoincrement())
  fileId Int
  file   File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name   String? // if songid is not there...
  song   Song?   @relation(fields: [songId], references: [id], onDelete: Cascade)
  songId Int?

  @@unique([fileId, songId]) // 
}

model FileEventTag {
  id      Int     @id @default(autoincrement())
  fileId  Int
  file    File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name    String? // if eventid is not there...
  event   Event?  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId Int?

  @@unique([fileId, eventId]) // 
}

model FileInstrumentTag {
  id           Int         @id @default(autoincrement())
  fileId       Int
  file         File        @relation(fields: [fileId], references: [id], onDelete: Cascade)
  name         String? // if instrumentid is not there...
  instrument   Instrument? @relation(fields: [instrumentId], references: [id], onDelete: Cascade)
  instrumentId Int?

  @@unique([fileId, instrumentId]) // 
}

// things like yes no maybe
model EventAttendance {
  id       Int    @id @default(autoincrement())
  text     String
  color    String
  strength Int // in order to be able to filter people who aren't coming.

  responses EventUserResponse[]
}

model EventApproval {
  id       Int    @id @default(autoincrement())
  text     String
  color    String
  strength Int // in order to be able to filter people who aren't coming.

  responses EventUserResponse[]
}

model EventUserResponse {
  id      Int   @id @default(autoincrement())
  userId  Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId Int
  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  expectApproval   Boolean @default(false)
  expectAttendance Boolean @default(false)

  attendanceId   Int?
  attendance     EventAttendance? @relation(fields: [attendanceId], references: [id], onDelete: SetDefault)
  attendanceText String?

  approvalId   Int?
  approval     EventApproval? @relation(fields: [approvalId], references: [id], onDelete: SetDefault)
  approvalText String?

  @@unique([userId, eventId]) // 
}
